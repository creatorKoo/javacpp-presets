// Targeted by JavaCPP version 1.4.1-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class MagickCore extends org.bytedeco.javacpp.presets.MagickCore {
    static { Loader.load(); }

// Parsed from <MagickCore/geometry.h>

/*
  Copyright 1999-2018 ImageMagick Studio LLC, a non-profit organization
  dedicated to making software imaging solutions freely available.

  You may not use this file except in compliance with the License.
  obtain a copy of the License at

    https://www.imagemagick.org/script/license.php

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  MagickCore image geometry methods.
*/
// #ifndef MAGICKCORE_GEOMETRY_H
// #define MAGICKCORE_GEOMETRY_H

// #if defined(__cplusplus) || defined(c_plusplus)
// #endif

/** enum GeometryFlags */
public static final int

  NoValue =  0x0000,
// #undef XValue
  XValue =  0x0001,
  XiValue =  0x0001,
// #undef YValue
  YValue =  0x0002,
  PsiValue =  0x0002,
// #undef WidthValue
  WidthValue =  0x0004,
  RhoValue =  0x0004,
// #undef HeightValue
  HeightValue =  0x0008,
  SigmaValue =  0x0008,
  ChiValue =  0x0010,
  XiNegative =  0x0020,
// #undef XNegative
  XNegative =  0x0020,
  PsiNegative =  0x0040,
// #undef YNegative
  YNegative =  0x0040,
  ChiNegative =  0x0080,
  PercentValue =  0x1000,    /* '%'  percentage of something */
  AspectValue =  0x2000,     /* '!'  resize no-aspect - special use flag */
  NormalizeValue =  0x2000,  /* '!'  ScaleKernelValue() in morphology.c */
  LessValue =  0x4000,       /* '<'  resize smaller - special use flag */
  GreaterValue =  0x8000,    /* '>'  resize larger - spacial use flag */
  MinimumValue =  0x10000,   /* '^'  special handling needed */
  CorrelateNormalizeValue =  0x10000, /* '^' see ScaleKernelValue() */
  AreaValue =  0x20000,      /* '@'  resize to area - special use flag */
  DecimalValue =  0x40000,   /* '.'  floating point numbers found */
  SeparatorValue =  0x80000, /* 'x'  separator found  */
  AspectRatioValue =  0x100000,    /* '~'  special handling needed  */
// #undef AllValues
  AllValues =  0x7fffffff;

// #if defined(ForgetGravity)
// #undef ForgetGravity
// #undef NorthWestGravity
// #undef NorthGravity
// #undef NorthEastGravity
// #undef WestGravity
// #undef CenterGravity
// #undef EastGravity
// #undef SouthWestGravity
// #undef SouthGravity
// #undef SouthEastGravity
// #endif

/** enum GravityType */
public static final int
  UndefinedGravity = 0,
  ForgetGravity = 0,
  NorthWestGravity = 1,
  NorthGravity = 2,
  NorthEastGravity = 3,
  WestGravity = 4,
  CenterGravity = 5,
  EastGravity = 6,
  SouthWestGravity = 7,
  SouthGravity = 8,
  SouthEastGravity = 9;

public static class AffineMatrix extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public AffineMatrix() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AffineMatrix(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AffineMatrix(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public AffineMatrix position(long position) {
        return (AffineMatrix)super.position(position);
    }

  public native double sx(); public native AffineMatrix sx(double sx);
  public native double rx(); public native AffineMatrix rx(double rx);
  public native double ry(); public native AffineMatrix ry(double ry);
  public native double sy(); public native AffineMatrix sy(double sy);
  public native double tx(); public native AffineMatrix tx(double tx);
  public native double ty(); public native AffineMatrix ty(double ty);
}

public static class GeometryInfo extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public GeometryInfo() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public GeometryInfo(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GeometryInfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public GeometryInfo position(long position) {
        return (GeometryInfo)super.position(position);
    }

  public native double rho(); public native GeometryInfo rho(double rho);
  public native double sigma(); public native GeometryInfo sigma(double sigma);
  public native double xi(); public native GeometryInfo xi(double xi);
  public native double psi(); public native GeometryInfo psi(double psi);
  public native double chi(); public native GeometryInfo chi(double chi);
}

public static class OffsetInfo extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OffsetInfo() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OffsetInfo(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OffsetInfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OffsetInfo position(long position) {
        return (OffsetInfo)super.position(position);
    }

  public native @Cast("ssize_t") long x(); public native OffsetInfo x(long x);
  public native @Cast("ssize_t") long y(); public native OffsetInfo y(long y);
}

public static class PointInfo extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PointInfo() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PointInfo(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PointInfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PointInfo position(long position) {
        return (PointInfo)super.position(position);
    }

  public native double x(); public native PointInfo x(double x);
  public native double y(); public native PointInfo y(double y);
}

public static class RectangleInfo extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public RectangleInfo() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public RectangleInfo(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RectangleInfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public RectangleInfo position(long position) {
        return (RectangleInfo)super.position(position);
    }

  public native @Cast("size_t") long width(); public native RectangleInfo width(long width);
  public native @Cast("size_t") long height(); public native RectangleInfo height(long height);

  public native @Cast("ssize_t") long x(); public native RectangleInfo x(long x);
  public native @Cast("ssize_t") long y(); public native RectangleInfo y(long y);
}
  
  
  
  
  
  
  
  
  
  

// #if defined(__cplusplus) || defined(c_plusplus)
// #endif

// #endif


}
